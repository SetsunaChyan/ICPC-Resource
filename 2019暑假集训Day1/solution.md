### A. Kaguya with Ice Creams

**算法：二维费用背包问题**

这道题是很明显的 0-1 背包问题，可是不同的是选一个雪糕会消耗**两种价值**（生产成本和生产时间）。这种问题其实很简单：方程基本不用变，只需再开一维数组，同时转移两个价值就行了！（完全、多重背包同理）

**这时候就要注意，再开一维存放雪糕编号就不合适了，因为容易 MLE。**



### B. Kaguya with Max Sum

**算法：一维数组前缀和**

一维数组前缀和的基本处理流程：

把对数组 A 的累加依次放入数组 B 中---B[i] = B[i-1] + A[i]，B[0]=A[0]。

这里要求计算k个连续的和的最大值，计算过程如：

$$
ans=f\{max(ans,B[k+i]-B[i])\ |\ 0 \leq i \lt n \ and\  k+i \lt n \}
$$

**ans的初值为B[k-1]，因为可能A数组的首项也可能属于符合条件的k个数！**



### C. Kaguya with Strings

**算法：string函数的应用**

本题主要考查的是同学们灵活应用string类型函数的能力，这里使用的是**substr**和**rfind**函数，substr用来截取子字符串，rfind函数用来从后面开始寻找子字符串的位置（**注意一下rfind和find的使用区别，想一想为什么这里使用rfind更合适**）。从字符串起始位置 $i(0 \leq i \leq s.size()-1)$ 开始截取一段长度为 $L(0\lt L\leq s.size()-1)$ ( $L$ 从大到小开始枚举)子字符串 $str1$ ，然后在 $i$ 后面的位置（不能包含 $i$ 位置）寻找是否存在子字符串 $str2$ ，满足 $str1==str2$ ，如果存在则输出 $L$ ；反之，如果遍历 $s$ 没有找到符合条件的两个子字符串，输出 $0$ 。



### D. ⑨

前置知识：类似于能被 $3$ 整除的数，各个数位加起来也能被 $3$ 整除，$9$ 也有相同的性质。
先不考虑最大化数，只考虑最大化位数，因为相同位数下将所选的数从大到小排是显然最优的。
原问题转化为取一些数，使得这些数的和 $\%9=0$ ，显而易见的结论是 $0$ 和 $9$ 全要，但是其他数有太多组合可以组出 $9$ ，对于不同的情况，他们的优先级并不唯一，比如 $1$ 个 $8$ 和 $9$ 个 $1$ 时，$8+1$ 和 $9$ 个 $1$ 相加，这两种情况的优先级是后者更高。贪心是很容易进也很容易发现的坑。
考虑 $dp$ ，常规思路，加一个数，有两种决策取或不取。并且我们不在意取的是什么数，只需要知道前 $i$ 个数，取一些加起来的余数即可。对 $9$ 的余数只有 $0-8$ 这九种情况，存下每种余数情况下，前 $i$ 个数中最多能取多少个达到这个余数。再试着加一个数进行转移。即最后只需要维护一个 $dp[i][余数]$，第一维可以滚动。
最后需要一个构造解，在 $dp$ 转移取优时记录前向路径。



### E. Lord

$3$ 分钟签到题。
一个循环 $01$ 数列，循环节为 $7$ ，求使得某连续段的和为 $k$ 时的最小段长。
记下完整的一周会上几天课，得到上课所需的完整周数，小心处理下两端的不完整周即可。



### F. Sweet Gem Berry

首先观察得到 $x$ 和 $y$ 两个轴是完全独立互不影响的，分开计算答案。
以 $x$ 轴为例，需要找到一个 $X$ ，使得所有矩形的 $x_l - x_r$ 这条线段，覆盖它。
一条线段 $[l,r]$ ，移动到 $X$ ，若线段在其左边，需要 $r-X$ ，若线段在其右边，需要 $X-l$ ，还有已覆盖的情况。
统一一下移动代价是 $(|r-X|+|X-l|-(r-l))/2$ ，提取出与X相关的部分，对于所有矩形，只需要最小化 $\sum (|r-X|+|X-l|)$
亦即，$l$ 和 $r$ 在地位上是没有区别的，所有的 $2n$ 个 $l$ 或 $r$，都需要与 $X$ 作差取绝对值求和。
所有数与中位数的绝对差之和最小，$X$ 取所有 $l$ 和 $r$ 的中位数就是答案。
实际做的时候只需要拍脑袋猜结论，暴力或者手算验证就能快速A掉。



### G. 射手座之日II

带权并查集。

维护每艘战舰到队头之间的战舰数、头部、尾部。

到队头之间的战舰数的值在路径压缩的时候就一起算上，查询的时候类似差分搞一搞就完了。



### H.  A Simple Problem On Different Numbers

树状数组/线段树。

如果稍微有一点经验就会发现，$a_i$ 的值域太大了，很难在线地回答。(尽管有在线做法)

考虑离线做法，把询问按右端点从小到大排序，依次回答。回答右端点为 $r$ 的询问时，维护好前 $r$ 个数自己是否为从右往左第一个出现的数。

维护操作很简单，因为询问是从左往右回答的，当维护到前 $k-1$ 个数时，数 $a_k$ 一定是从右往左的第一个 $a_k$ ，如果 $a_k$ 曾经在位置 $p$ 出现过，那么就 $add(p,-1)$ 。然后无论它是否出现过，执行 $add(k,1)$ 来标记他是从右往左第一个出现的。重复这个操作直到维护完前 $r$ 个。

此时这个询问的答案就是 $sum(r)-sum(l-1)$。



### I. A Simple Problem On Graph

$BFS$ 或 $DFS$ 随便搞。

把图黑白染色，如果相邻两点同色则一定无解。

每个联通块内要删掉的点的个数就是 $min(黑点数,白点数)$ 。因为每条边的两侧一定是一个黑点一个白点，而且一旦删了黑点就不可能再删白点了，反之亦然。