### A. Kaguya with Ice Creams

**算法：二维费用背包问题**

这道题是很明显的 0-1 背包问题，可是不同的是选一个雪糕会消耗**两种价值**（生产成本和生产时间）。这种问题其实很简单：方程基本不用变，只需再开一维数组，同时转移两个价值就行了！（完全、多重背包同理）

**这时候就要注意，再开一维存放雪糕编号就不合适了，因为容易 MLE。**



### B. Kaguya with Max Sum

**算法：一维数组前缀和**

一维数组前缀和的基本处理流程：

把对数组 A 的累加依次放入数组 B 中---B[i] = B[i-1] + A[i]，B[0]=A[0]。

这里要求计算k个连续的和的最大值，计算过程如：

$$
ans=f\{max(ans,B[k+i]-B[i])\ |\ 0 \leq i \lt n \ and\  k+i \lt n \}
$$

**ans的初值为B[k-1]，因为可能A数组的首项也可能属于符合条件的k个数！**



### C. Kaguya with Strings

**算法：string函数的应用**

本题主要考查的是同学们灵活应用string类型函数的能力，这里使用的是**substr**和**rfind**函数，substr用来截取子字符串，rfind函数用来从后面开始寻找子字符串的位置（**注意一下rfind和find的使用区别，想一想为什么这里使用rfind更合适**）。从字符串起始位置 $i(0 \leq i \leq s.size()-1)$ 开始截取一段长度为 $L(0\lt L\leq s.size()-1)$ ( $L$ 从大到小开始枚举)子字符串 $str1$ ，然后在 $i$ 后面的位置（不能包含 $i$ 位置）寻找是否存在子字符串 $str2$ ，满足 $str1==str2$ ，如果存在则输出 $L$ ；反之，如果遍历 $s$ 没有找到符合条件的两个子字符串，输出 $0$ 。



### D. ⑨



### E. Lord



### F. Sweet Gem Berry





### G. 射手座之日II

带权并查集。

维护每艘战舰到队头之间的战舰数、头部、尾部。

到队头之间的战舰数的值在路径压缩的时候就一起算上，查询的时候类似差分搞一搞就完了。



### H.  A Simple Problem On Different Numbers

树状数组/线段树。

如果稍微有一点经验就会发现，$a_i$ 的值域太大了，很难在线地回答。(尽管有在线做法)

考虑离线做法，把询问按右端点从小到大排序，依次回答。回答右端点为 $r$ 的询问时，维护好前 $r$ 个数自己是否为从右往左第一个出现的数。

维护操作很简单，因为询问是从左往右回答的，当维护到前 $k-1$ 个数时，数 $a_k$ 一定是从右往左的第一个 $a_k$ ，如果 $a_k$ 曾经在位置 $p$ 出现过，那么就 $add(p,-1)$ 。然后无论它是否出现过，执行 $add(k,1)$ 来标记他是从右往左第一个出现的。重复这个操作直到维护完前 $r$ 个。

此时这个询问的答案就是 $sum(r)-sum(l-1)$。



### I. A Simple Problem On Graph

$BFS$ 或 $DFS$ 随便搞。

把图黑白染色，如果相邻两点同色则一定无解。

每个联通块内要删掉的点的个数就是 $min(黑点数,白点数)$ 。因为每条边的两侧一定是一个黑点一个白点，而且一旦删了黑点就不可能再删白点了，反之亦然。